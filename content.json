{"meta":{"title":"丿歌吟有梦","subtitle":"不要让任何事成为你不学习的理由!","description":"Android博客网站","author":"丁军伟","url":"http://itdais.com"},"pages":[{"title":"tags","date":"2016-07-05T15:29:13.000Z","updated":"2016-07-05T15:31:45.162Z","comments":false,"path":"tags/index.html","permalink":"http://itdais.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"BottomSheet使用详解","slug":"BottomSheet使用详解","date":"2016-10-11T16:00:00.000Z","updated":"2016-10-13T02:05:46.051Z","comments":true,"path":"2016/10/12/BottomSheet使用详解/","link":"","permalink":"http://itdais.com/2016/10/12/BottomSheet使用详解/","excerpt":"","text":"BottomSheet使用详解Android Support Library 23.2里的 Design Support Library新加了一个Bottom Sheets控件,Bottom Sheets顾名思义就是底部操作控件，用于在屏幕底部创建一个可滑动关闭的视图，可以替代对话框和菜单。其中包含BottomSheets、BottomSheetDialog和BottomSheetDialogFragment三种可以使用。 BottomSheets常见的效果如图,并且在国内的知乎、百度地图上也是可以看到效果。 首先我们学习使用BottomSheets，BottomSheets其实也是依赖于Behavior机制的使用。先引用依赖,最新的design包已经到24了1compile 'com.android.support:design:24.2.1' BottomSheets在布局文件xml中的使用,BottomSheets需要配合CoordinatorLayout控件12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.design.widget.CoordinatorLayout android:id=\"@+id/cl\" xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:fitsSystemWindows=\"true\"&gt; &lt;android.support.v4.widget.NestedScrollView android:id=\"@+id/bottom_sheet\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" app:behavior_hideable=\"true\" app:behavior_peekHeight=\"50dp\" app:layout_behavior=\"@string/bottom_sheet_behavior\"&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\"&gt; &lt;!-- 你自己的代码--&gt; &lt;/LinearLayout&gt; &lt;/android.support.v4.widget.NestedScrollView&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; 其中包含三个属性123app:behavior_hideable=&quot;true&quot;app:behavior_peekHeight=&quot;0dp&quot;app:layout_behavior=&quot;@string/bottom_sheet_behavior&quot; app:behavior_peekHeight=”50dp” peekHeight是当Bottom Sheets关闭的时候，底部我们能看到的高度,默认是0不可见。 app:behavior_hideable=”true” hideable是当我们拖拽下拉的时候，bottom sheet是否能全部隐藏。 layout_behavior指向bottom_sheet_behavior,代表这是一个bottom Sheets 在java代码中的使用12345678910111213141516171819202122BottomSheetBehavior behavior; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_bottom_sheet); View bottomSheet = findViewById(R.id.bottom_sheet); behavior = BottomSheetBehavior.from(bottomSheet); behavior.setBottomSheetCallback(new BottomSheetBehavior.BottomSheetCallback() &#123; @Override public void onStateChanged(@NonNull View bottomSheet, int newState) &#123; //这里是bottomSheet状态的改变 &#125; @Override public void onSlide(@NonNull View bottomSheet, float slideOffset) &#123; //这里是拖拽中的回调，根据slideOffset可以做一些动画 &#125; &#125;); &#125; behavior_hideable对应代码 behavior.setHideable(false);behavior_peekHeight对应代码 behavior.setPeekHeight(50); setBottomSheetCallback可以监听回调的状态,onStateChanged监听状态的改变,onSlide是拖拽的回调,onStateChanged可以监听到的回调一共有5种: STATE_HIDDEN: 隐藏状态。默认是false，可通过app:behavior_hideable属性设置。 STATE_COLLAPSED: 折叠关闭状态。可通过app:behavior_peekHeight来设置显示的高度,peekHeight默认是0。 STATE_DRAGGING: 被拖拽状态 STATE_SETTLING: 拖拽松开之后到达终点位置（collapsed or expanded）前的状态。 STATE_EXPANDED: 完全展开的状态。BottomSheets控件配合NestedScrollView、RecyclerView使用效果会更好,合理的使用让APP逼格满满。 我们需要在按钮按钮上添加对BottomSheets的显示和隐藏 12345if(behavior.getState() == BottomSheetBehavior.STATE_EXPANDED) &#123; behavior.setState(BottomSheetBehavior.STATE_COLLAPSED);&#125;else &#123; behavior.setState(BottomSheetBehavior.STATE_EXPANDED);&#125; 效果如图: design24.2.1的BottomSheets和23.2.0的BottomSheet有很大的区别,design23.2.0的包中如果你使用了BottomSheet,可以在屏幕外任何位置上拉即可拉出来布局,在24.2.1中没有了这个效果。 BottomSheetDialogBottomSheetDialog应该是最实用的控件,也是使用率非常高的控件。它可以替代大多数网格显示和列表展示的dialog和popupwindow，默认宽度撑满，并且在BottomSheetDialog 区域中向下滑动也让对话框消失。 首先写一个dialog展示的xml，dialog中xml可以不用被CoordinatorLayout包裹，但是还是推荐实用推荐的滑动控件NestedScrollView1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.v4.widget.NestedScrollView xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"&gt; &lt;TextView android:onClick=\"doclick\" android:layout_width=\"match_parent\" android:layout_height=\"100dp\" android:background=\"@color/colorPrimary\" android:gravity=\"center\" android:text=\"啦啦啦啦啦啦啦啦啦\" android:textColor=\"@color/white\" android:textSize=\"18sp\"/&gt; &lt;ImageView android:onClick=\"doclick\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:scaleType=\"centerCrop\" android:src=\"@drawable/banner\"/&gt; &lt;/LinearLayout&gt;&lt;/android.support.v4.widget.NestedScrollView&gt; 编写java代码1234BottomSheetDialog dialog = new BottomSheetDialog(this);View view = getLayoutInflater().inflate(R.layout.dialog_bottom_sheet, null);dialog.setContentView(view);dialog.show(); 只需要四行我们就可以展示BottomSheets效果的dialog,高度为你设置的behavior_peekHeight或者默认高度，宽度撑满。在很多情况底部显示dialog的时候，都可以考虑实用BottomSheetDialog来实现。效果如图: BottomSheetDialogFragmentBottomSheetDialogFragment可以帮助我们实现全屏的BottomSheet展示效果。新建一个类继承BottomSheetDialogFragment xml使用BottomSheetDialog的布局样式,我们直接看java代码 1234567891011121314151617181920212223242526public class FullSheetDialogFragment extends BottomSheetDialogFragment &#123; private BottomSheetBehavior mBehavior; @Override public Dialog onCreateDialog(Bundle savedInstanceState) &#123; BottomSheetDialog dialog = (BottomSheetDialog) super.onCreateDialog(savedInstanceState); View view = View.inflate(getContext(), R.layout.dialog_bottom_sheet, null); dialog.setContentView(view); mBehavior = BottomSheetBehavior.from((View) view.getParent()); return dialog; &#125; @Override public void onStart() &#123; super.onStart(); //默认全屏展开 mBehavior.setState(BottomSheetBehavior.STATE_EXPANDED); &#125; public void doclick(View v) &#123; //点击任意布局关闭 mBehavior.setState(BottomSheetBehavior.STATE_HIDDEN); &#125;&#125; 调用BottomSheetDialogFragment展示 1new FullSheetDialogFragment().show(getSupportFragmentManager(), \"dialog\"); BottomSheetDialogFragment的效果跟BottomSheetDialog差不多,根据情况选择。效果如图: BottomSheetDialog就介绍到此，如果有错误请指出，谢谢。 参考：泡在网上的日子BottomSheets的使用 个人网站 歌吟有梦 itdais.com 更多内容可以关注我的公众号：丁军伟Dev（或者搜索DingAndroid）","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://itdais.com/tags/Android/"},{"name":"Gradle","slug":"Gradle","permalink":"http://itdais.com/tags/Gradle/"}]},{"title":"Android Studio运行时候报packageOfficialDebug错误","slug":"Android Studio运行时候报packageOfficialDebug错误","date":"2016-10-10T16:00:00.000Z","updated":"2016-10-13T02:00:31.032Z","comments":true,"path":"2016/10/11/Android Studio运行时候报packageOfficialDebug错误/","link":"","permalink":"http://itdais.com/2016/10/11/Android Studio运行时候报packageOfficialDebug错误/","excerpt":"","text":"Android Studio运行时候报packageOfficialDebug错误报错信息为 Error:A problem was found with the configuration of task’:watch:packageOfficialDebug’.File ‘…\\build\\intermediates\\res\\resources-official-debug-stripped.ap_’ specified for property ‘resourceFile’ does not exist. 解决方法一:这个大多数原因是开启了混淆造成的,关闭Debug模式下的混淆开关后重新编译即可,代码如下: 1234567891011121314buildTypes &#123; release &#123; buildConfigField(&quot;boolean&quot;, &quot;LOG_DEBUG&quot;, &quot;false&quot;) minifyEnabled true shrinkResources true proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; &#125; debug &#123; minifyEnabled false shrinkResources false buildConfigField(&quot;boolean&quot;, &quot;LOG_DEBUG&quot;, &quot;true&quot;) proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; &#125; &#125; minifyEnabled即以前的runProguard,用来控制是否混淆。 shrinkResources为true时自动去掉多余资源。 注：Gradle2.0以上的版本minifyEnabled字段为true时已经包含了shrinkResources,在代码优化时会自动去掉多余资源，所以在打正式包时也不需要设置shrinkResources字段。 解决方法二:Android Studio2.0以上有了Instant Run功能,很多情况下运行报错都跟Instant Run有关进入File –&gt; Setting(Ctrl+Alt+S)找到InstantRun功能,把InstantRun功能关闭","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://itdais.com/tags/Android/"},{"name":"Gradle","slug":"Gradle","permalink":"http://itdais.com/tags/Gradle/"}]},{"title":"AS运行时异常(一)","slug":"AS运行时异常(一)","date":"2016-09-25T13:01:00.000Z","updated":"2016-09-05T13:35:22.539Z","comments":true,"path":"2016/09/25/AS运行时异常(一)/","link":"","permalink":"http://itdais.com/2016/09/25/AS运行时异常(一)/","excerpt":"","text":"从Github上下载了一个demo ,但是Android Studio一直运行不成功,爆出了下面的错误1234Error:(1, 1) A problem occurred evaluating project &apos;:app&apos;.&gt; Failed to apply plugin [id &apos;com.android.application&apos;] &gt; Gradle version 2.10 is required. Current version is 2.8. If using the gradle wrapper, try editing the distributionUrl in E:\\workspace\\GitHub\\RxJavaApp-master\\gradle\\wrapper\\gradle-wrapper.properties to gradle-2.10-all.zip Message提醒为: Warning:Gradle version 2.10 is required. Current version is 2.8. Ifusing the gradle wrapper 解决方法为:File - Project Structure(Ctrl+Alt+Shift+S) - Project - 更改Gradle Version 为2.10 附:因为我本地已经有了2.10的Gradle版本,所以如果你没有该版本请下载或者更高其他版本试试","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://itdais.com/tags/Android/"},{"name":"Gradle","slug":"Gradle","permalink":"http://itdais.com/tags/Gradle/"}]},{"title":"Android Session失效重连","slug":"Android-Session失效重连","date":"2016-09-08T02:26:57.000Z","updated":"2016-09-08T02:26:57.903Z","comments":true,"path":"2016/09/08/Android-Session失效重连/","link":"","permalink":"http://itdais.com/2016/09/08/Android-Session失效重连/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Glide Transform","slug":"Glide Transform圆型图片和圆角图片","date":"2016-08-28T13:10:49.000Z","updated":"2016-08-29T13:27:32.787Z","comments":true,"path":"2016/08/28/Glide Transform圆型图片和圆角图片/","link":"","permalink":"http://itdais.com/2016/08/28/Glide Transform圆型图片和圆角图片/","excerpt":"本文介绍Glide通过Transform转换圆形图片和圆角图片","text":"本文介绍Glide通过Transform转换圆形图片和圆角图片 1、圆形转换器123456789101112131415161718192021222324252627282930313233343536373839public class GlideCircleTransform extends BitmapTransformation &#123; public GlideCircleTransform(Context context) &#123; super(context); &#125; @Override protected Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, int outHeight) &#123; return circleCrop(pool, toTransform); &#125; private static Bitmap circleCrop(BitmapPool pool, Bitmap source) &#123; if (source == null) return null; int size = Math.min(source.getWidth(), source.getHeight()); int x = (source.getWidth() - size) / 2; int y = (source.getHeight() - size) / 2; // TODO this could be acquired from the pool too Bitmap squared = Bitmap.createBitmap(source, x, y, size, size); Bitmap result = pool.get(size, size, Bitmap.Config.ARGB_8888); if (result == null) &#123; result = Bitmap.createBitmap(size, size, Bitmap.Config.ARGB_8888); &#125; Canvas canvas = new Canvas(result); Paint paint = new Paint(); paint.setShader(new BitmapShader(squared, BitmapShader.TileMode.CLAMP, BitmapShader.TileMode.CLAMP)); paint.setAntiAlias(true); float r = size / 2f; canvas.drawCircle(r, r, r, paint); return result; &#125; @Override public String getId() &#123; return getClass().getName(); &#125;&#125; 使用 Glide.with(context).load(url) .placeholder(R.drawable.def_header) .transform(new GlideCircleTransform(context)) .into(view); 2、圆角转换器可以传参设置圆角的角度,不传默认4 12345678910111213141516171819202122232425262728293031323334353637public class GlideRoundTransform extends BitmapTransformation &#123; private static float radius = 0f; public GlideRoundTransform(Context context) &#123; this(context, 4); &#125; public GlideRoundTransform(Context context, int dp) &#123; super(context); this.radius = Resources.getSystem().getDisplayMetrics().density * dp; &#125; @Override protected Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, int outHeight) &#123; return roundCrop(pool, toTransform); &#125; private static Bitmap roundCrop(BitmapPool pool, Bitmap source) &#123; if (source == null) return null; Bitmap result = pool.get(source.getWidth(), source.getHeight(), Bitmap.Config.ARGB_8888); if (result == null) &#123; result = Bitmap.createBitmap(source.getWidth(), source.getHeight(), Bitmap.Config.ARGB_8888); &#125; Canvas canvas = new Canvas(result); Paint paint = new Paint(); paint.setShader(new BitmapShader(source, BitmapShader.TileMode.CLAMP, BitmapShader.TileMode.CLAMP)); paint.setAntiAlias(true); RectF rectF = new RectF(0f, 0f, source.getWidth(), source.getHeight()); canvas.drawRoundRect(rectF, radius, radius, paint); return result; &#125; @Override public String getId() &#123; return getClass().getName() + Math.round(radius); &#125;&#125; 使用 Glide.with(context).load(url) .placeholder(R.drawable.transparent) .transform(new GlideRoundTransform(context)) .into(view);","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://itdais.com/tags/Android/"},{"name":"图片加载","slug":"图片加载","permalink":"http://itdais.com/tags/图片加载/"},{"name":"Glide","slug":"Glide","permalink":"http://itdais.com/tags/Glide/"}]},{"title":"自定义圆型控件","slug":"自定义圆型控件","date":"2016-08-28T13:10:13.000Z","updated":"2016-08-29T13:23:28.640Z","comments":true,"path":"2016/08/28/自定义圆型控件/","link":"","permalink":"http://itdais.com/2016/08/28/自定义圆型控件/","excerpt":"自定义圆形控件,CircleImageView和RoundImageView,其中使用CircleImageView,可以被Glide使用使用RoundImageView,不可以被Glide使用,可以设置双边框","text":"自定义圆形控件,CircleImageView和RoundImageView,其中使用CircleImageView,可以被Glide使用使用RoundImageView,不可以被Glide使用,可以设置双边框 1、CircleImageView123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269public class CircleImageView extends ImageView &#123; private static final ScaleType SCALE_TYPE = ScaleType.CENTER_CROP; private static final Bitmap.Config BITMAP_CONFIG = Bitmap.Config.ARGB_8888; private static final int COLORDRAWABLE_DIMENSION = 2; private static final int DEFAULT_BORDER_WIDTH = 0; private static final int DEFAULT_BORDER_COLOR = Color.BLACK; private static final int DEFAULT_FILL_COLOR = Color.TRANSPARENT; private static final boolean DEFAULT_BORDER_OVERLAY = false; private final RectF mDrawableRect = new RectF(); private final RectF mBorderRect = new RectF(); private final Matrix mShaderMatrix = new Matrix(); private final Paint mBitmapPaint = new Paint(); private final Paint mBorderPaint = new Paint(); private final Paint mFillPaint = new Paint(); private int mBorderColor = DEFAULT_BORDER_COLOR; private int mBorderWidth = DEFAULT_BORDER_WIDTH; private int mFillColor = DEFAULT_FILL_COLOR; private Bitmap mBitmap; private BitmapShader mBitmapShader; private int mBitmapWidth; private int mBitmapHeight; private float mDrawableRadius; private float mBorderRadius; private ColorFilter mColorFilter; private boolean mReady; private boolean mSetupPending; private boolean mBorderOverlay; public CircleImageView(Context context) &#123; super(context); init(); &#125; public CircleImageView(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public CircleImageView(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.CircleImageView, defStyle, 0); mBorderWidth = a.getDimensionPixelSize(R.styleable.CircleImageView_civ_border_width, DEFAULT_BORDER_WIDTH); mBorderColor = a.getColor(R.styleable.CircleImageView_civ_border_color, DEFAULT_BORDER_COLOR); mBorderOverlay = a.getBoolean(R.styleable.CircleImageView_civ_border_overlay, DEFAULT_BORDER_OVERLAY); mFillColor = a.getColor(R.styleable.CircleImageView_civ_fill_color, DEFAULT_FILL_COLOR); a.recycle(); init(); &#125; private void init() &#123; super.setScaleType(SCALE_TYPE); mReady = true; if (mSetupPending) &#123; setup(); mSetupPending = false; &#125; &#125; @Override public ScaleType getScaleType() &#123; return SCALE_TYPE; &#125; @Override public void setScaleType(ScaleType scaleType) &#123; if (scaleType != SCALE_TYPE) &#123; throw new IllegalArgumentException(String.format(\"ScaleType %s not supported.\", scaleType)); &#125; &#125; @Override public void setAdjustViewBounds(boolean adjustViewBounds) &#123; if (adjustViewBounds) &#123; throw new IllegalArgumentException(\"adjustViewBounds not supported.\"); &#125; &#125; @Override protected void onDraw(Canvas canvas) &#123; if (mBitmap == null) &#123; return; &#125; if (mFillColor != Color.TRANSPARENT) &#123; canvas.drawCircle(getWidth() / 2.0f, getHeight() / 2.0f, mDrawableRadius, mFillPaint); &#125; canvas.drawCircle(getWidth() / 2.0f, getHeight() / 2.0f, mDrawableRadius, mBitmapPaint); if (mBorderWidth != 0) &#123; canvas.drawCircle(getWidth() / 2.0f, getHeight() / 2.0f, mBorderRadius, mBorderPaint); &#125; &#125; @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); setup(); &#125; public int getBorderColor() &#123; return mBorderColor; &#125; public void setBorderColor(int borderColor) &#123; if (borderColor == mBorderColor) &#123; return; &#125; mBorderColor = borderColor; mBorderPaint.setColor(mBorderColor); invalidate(); &#125; public void setBorderColorResource(int borderColorRes) &#123; setBorderColor(getContext().getResources().getColor(borderColorRes)); &#125; public int getFillColor() &#123; return mFillColor; &#125; public void setFillColor(int fillColor) &#123; if (fillColor == mFillColor) &#123; return; &#125; mFillColor = fillColor; mFillPaint.setColor(fillColor); invalidate(); &#125; public void setFillColorResource(int fillColorRes) &#123; setFillColor(getContext().getResources().getColor(fillColorRes)); &#125; public int getBorderWidth() &#123; return mBorderWidth; &#125; public void setBorderWidth(int borderWidth) &#123; if (borderWidth == mBorderWidth) &#123; return; &#125; mBorderWidth = borderWidth; setup(); &#125; public boolean isBorderOverlay() &#123; return mBorderOverlay; &#125; public void setBorderOverlay(boolean borderOverlay) &#123; if (borderOverlay == mBorderOverlay) &#123; return; &#125; mBorderOverlay = borderOverlay; setup(); &#125; @Override public void setImageBitmap(Bitmap bm) &#123; super.setImageBitmap(bm); mBitmap = bm; setup(); &#125; @Override public void setImageDrawable(Drawable drawable) &#123; super.setImageDrawable(drawable); mBitmap = getBitmapFromDrawable(drawable); setup(); &#125; @Override public void setImageResource(int resId) &#123; super.setImageResource(resId); mBitmap = getBitmapFromDrawable(getDrawable()); setup(); &#125; @Override public void setImageURI(Uri uri) &#123; super.setImageURI(uri); mBitmap = uri != null ? getBitmapFromDrawable(getDrawable()) : null; setup(); &#125; @Override public void setColorFilter(ColorFilter cf) &#123; if (cf == mColorFilter) &#123; return; &#125; mColorFilter = cf; mBitmapPaint.setColorFilter(mColorFilter); invalidate(); &#125; private Bitmap getBitmapFromDrawable(Drawable drawable) &#123; if (drawable == null) &#123; return null; &#125; if (drawable instanceof BitmapDrawable) &#123; return ((BitmapDrawable) drawable).getBitmap(); &#125; try &#123; Bitmap bitmap; if (drawable instanceof ColorDrawable) &#123; bitmap = Bitmap.createBitmap(COLORDRAWABLE_DIMENSION, COLORDRAWABLE_DIMENSION, BITMAP_CONFIG); &#125; else &#123; bitmap = Bitmap.createBitmap(drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight(), BITMAP_CONFIG); &#125; Canvas canvas = new Canvas(bitmap); drawable.setBounds(0, 0, canvas.getWidth(), canvas.getHeight()); drawable.draw(canvas); return bitmap; &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125; private void setup() &#123; if (!mReady) &#123; mSetupPending = true; return; &#125; if (getWidth() == 0 &amp;&amp; getHeight() == 0) &#123; return; &#125; if (mBitmap == null) &#123; invalidate(); return; &#125; mBitmapShader = new BitmapShader(mBitmap, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP); mBitmapPaint.setAntiAlias(true); mBitmapPaint.setShader(mBitmapShader); mBorderPaint.setStyle(Paint.Style.STROKE); mBorderPaint.setAntiAlias(true); mBorderPaint.setColor(mBorderColor); mBorderPaint.setStrokeWidth(mBorderWidth); mFillPaint.setStyle(Paint.Style.FILL); mFillPaint.setAntiAlias(true); mFillPaint.setColor(mFillColor); mBitmapHeight = mBitmap.getHeight(); mBitmapWidth = mBitmap.getWidth(); mBorderRect.set(0, 0, getWidth(), getHeight()); mBorderRadius = Math.min((mBorderRect.height() - mBorderWidth) / 2.0f, (mBorderRect.width() - mBorderWidth) / 2.0f); mDrawableRect.set(mBorderRect); if (!mBorderOverlay) &#123; mDrawableRect.inset(mBorderWidth, mBorderWidth); &#125; mDrawableRadius = Math.min(mDrawableRect.height() / 2.0f, mDrawableRect.width() / 2.0f); updateShaderMatrix(); invalidate(); &#125; private void updateShaderMatrix() &#123; float scale; float dx = 0; float dy = 0; mShaderMatrix.set(null); if (mBitmapWidth * mDrawableRect.height() &gt; mDrawableRect.width() * mBitmapHeight) &#123; scale = mDrawableRect.height() / (float) mBitmapHeight; dx = (mDrawableRect.width() - mBitmapWidth * scale) * 0.5f; &#125; else &#123; scale = mDrawableRect.width() / (float) mBitmapWidth; dy = (mDrawableRect.height() - mBitmapHeight * scale) * 0.5f; &#125; mShaderMatrix.setScale(scale, scale); mShaderMatrix.postTranslate((int) (dx + 0.5f) + mDrawableRect.left, (int) (dy + 0.5f) + mDrawableRect.top); mBitmapShader.setLocalMatrix(mShaderMatrix); &#125;&#125; attrs123456&lt;declare-styleable name=\"CircleImageView\"&gt; &lt;attr name=\"civ_border_width\" format=\"dimension\" /&gt; &lt;attr name=\"civ_border_color\" format=\"color\" /&gt; &lt;attr name=\"civ_border_overlay\" format=\"boolean\" /&gt; &lt;attr name=\"civ_fill_color\" format=\"color\" /&gt;&lt;/declare-styleable&gt; 2、RoundImageView123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162/** * 圆形ImageView，可设置最多两个宽度不同且颜色不同的圆形边框。 设置颜色在xml布局文件中由自定义属性配置参数指定 */public class RoundImageView extends ImageView &#123; private int mBorderThickness = 0; private Context mContext; private int defaultColor = 0xFFFFFFFF; // 如果只有其中一个有值，则只画一个圆形边框 private int mBorderOutsideColor = 0; private int mBorderInsideColor = 0; // 控件默认长、宽 private int defaultWidth = 0; private int defaultHeight = 0; public RoundImageView(Context context) &#123; super(context); mContext = context; &#125; public RoundImageView(Context context, AttributeSet attrs) &#123; super(context, attrs); mContext = context; setCustomAttributes(attrs); &#125; public RoundImageView(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); mContext = context; setCustomAttributes(attrs); &#125; private void setCustomAttributes(AttributeSet attrs) &#123; TypedArray a = mContext.obtainStyledAttributes(attrs, R.styleable.roundedimageview); mBorderThickness = a.getDimensionPixelSize(R.styleable.roundedimageview_border_thickness, 0); mBorderOutsideColor = a.getColor(R.styleable.roundedimageview_border_outside_color, defaultColor); mBorderInsideColor = a.getColor(R.styleable.roundedimageview_border_inside_color, defaultColor); &#125; @Override protected void onDraw(Canvas canvas) &#123; Drawable drawable = getDrawable(); if (drawable == null) &#123; return; &#125; if (getWidth() == 0 || getHeight() == 0) &#123; return; &#125; this.measure(0, 0); if (drawable.getClass() == NinePatchDrawable.class) return; Bitmap b = ((BitmapDrawable) drawable).getBitmap(); Bitmap bitmap = b.copy(Bitmap.Config.ARGB_8888, true); if (defaultWidth == 0) &#123; defaultWidth = getWidth(); &#125; if (defaultHeight == 0) &#123; defaultHeight = getHeight(); &#125; int radius = 0; if (mBorderInsideColor != defaultColor &amp;&amp; mBorderOutsideColor != defaultColor) &#123;// 定义画两个边框，分别为外圆边框和内圆边框 radius = (defaultWidth &lt; defaultHeight ? defaultWidth : defaultHeight) / 2 - 2 * mBorderThickness; // 画内圆 drawCircleBorder(canvas, radius + mBorderThickness / 2, mBorderInsideColor); // 画外圆 drawCircleBorder(canvas, radius + mBorderThickness + mBorderThickness / 2, mBorderOutsideColor); &#125; else if (mBorderInsideColor != defaultColor &amp;&amp; mBorderOutsideColor == defaultColor) &#123;// 定义画一个边框 radius = (defaultWidth &lt; defaultHeight ? defaultWidth : defaultHeight) / 2 - mBorderThickness; drawCircleBorder(canvas, radius + mBorderThickness / 2, mBorderInsideColor); &#125; else if (mBorderInsideColor == defaultColor &amp;&amp; mBorderOutsideColor != defaultColor) &#123;// 定义画一个边框 radius = (defaultWidth &lt; defaultHeight ? defaultWidth : defaultHeight) / 2 - mBorderThickness; drawCircleBorder(canvas, radius + mBorderThickness / 2, mBorderOutsideColor); &#125; else &#123;// 没有边框 radius = (defaultWidth &lt; defaultHeight ? defaultWidth : defaultHeight) / 2; &#125; Bitmap roundBitmap = getCroppedRoundBitmap(bitmap, radius); canvas.drawBitmap(roundBitmap, defaultWidth / 2 - radius, defaultHeight / 2 - radius, null); &#125; /** * 获取裁剪后的圆形图片 * * @param radius 半径 */ public Bitmap getCroppedRoundBitmap(Bitmap bmp, int radius) &#123; Bitmap scaledSrcBmp; int diameter = radius * 2; // 为了防止宽高不相等，造成圆形图片变形，因此截取长方形中处于中间位置最大的正方形图片 int bmpWidth = bmp.getWidth(); int bmpHeight = bmp.getHeight(); int squareWidth = 0, squareHeight = 0; int x = 0, y = 0; Bitmap squareBitmap; if (bmpHeight &gt; bmpWidth) &#123;// 高大于宽 squareWidth = squareHeight = bmpWidth; x = 0; y = (bmpHeight - bmpWidth) / 2; // 截取正方形图片 squareBitmap = Bitmap.createBitmap(bmp, x, y, squareWidth, squareHeight); &#125; else if (bmpHeight &lt; bmpWidth) &#123;// 宽大于高 squareWidth = squareHeight = bmpHeight; x = (bmpWidth - bmpHeight) / 2; y = 0; squareBitmap = Bitmap.createBitmap(bmp, x, y, squareWidth, squareHeight); &#125; else &#123; squareBitmap = bmp; &#125; if (squareBitmap.getWidth() != diameter || squareBitmap.getHeight() != diameter) &#123; scaledSrcBmp = Bitmap.createScaledBitmap(squareBitmap, diameter, diameter, true); &#125; else &#123; scaledSrcBmp = squareBitmap; &#125; Bitmap output = Bitmap.createBitmap(scaledSrcBmp.getWidth(), scaledSrcBmp.getHeight(), Config.ARGB_8888); Canvas canvas = new Canvas(output); Paint paint = new Paint(); Rect rect = new Rect(0, 0, scaledSrcBmp.getWidth(), scaledSrcBmp.getHeight()); paint.setAntiAlias(true); paint.setFilterBitmap(true); paint.setDither(true); canvas.drawARGB(0, 0, 0, 0); canvas.drawCircle(scaledSrcBmp.getWidth() / 2, scaledSrcBmp.getHeight() / 2, scaledSrcBmp.getWidth() / 2, paint); paint.setXfermode(new PorterDuffXfermode(Mode.SRC_IN)); canvas.drawBitmap(scaledSrcBmp, rect, rect, paint); bmp = null; squareBitmap = null; scaledSrcBmp = null; return output; &#125; /** * 边缘画圆 */ private void drawCircleBorder(Canvas canvas, int radius, int color) &#123; Paint paint = new Paint(); /* 去锯齿 */ paint.setAntiAlias(true); paint.setFilterBitmap(true); paint.setDither(true); paint.setColor(color); /* 设置paint的 style 为STROKE：空心 */ paint.setStyle(Paint.Style.STROKE); /* 设置paint的外框宽度 */ paint.setStrokeWidth(mBorderThickness); canvas.drawCircle(defaultWidth / 2, defaultHeight / 2, radius, paint); &#125;&#125; attrs12345&lt;declare-styleable name=\"roundedimageview\"&gt; &lt;attr name=\"border_thickness\" format=\"dimension\" /&gt; &lt;attr name=\"border_inside_color\" format=\"color\" /&gt; &lt;attr name=\"border_outside_color\" format=\"color\"&gt;&lt;/attr&gt;&lt;/declare-styleable&gt; 如果用Glide推荐用transForm转换","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://itdais.com/tags/Android/"},{"name":"图片加载","slug":"图片加载","permalink":"http://itdais.com/tags/图片加载/"},{"name":"自定义控件","slug":"自定义控件","permalink":"http://itdais.com/tags/自定义控件/"}]},{"title":"AppCrash崩溃监听","slug":"Crash崩溃监听","date":"2016-08-28T13:06:29.000Z","updated":"2016-08-28T13:06:29.636Z","comments":true,"path":"2016/08/28/Crash崩溃监听/","link":"","permalink":"http://itdais.com/2016/08/28/Crash崩溃监听/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"ScrollView嵌套ListView,GridView,ExpandableListView","slug":"ScrollView嵌套ListView-GridView-ExpandableListView","date":"2016-08-26T12:14:15.000Z","updated":"2016-08-26T12:14:15.392Z","comments":true,"path":"2016/08/26/ScrollView嵌套ListView-GridView-ExpandableListView/","link":"","permalink":"http://itdais.com/2016/08/26/ScrollView嵌套ListView-GridView-ExpandableListView/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"SwipeToRefresh滑动冲突解决","slug":"SwipeToRefresh滑动冲突解决","date":"2016-08-25T13:59:14.000Z","updated":"2016-08-25T14:03:50.159Z","comments":true,"path":"2016/08/25/SwipeToRefresh滑动冲突解决/","link":"","permalink":"http://itdais.com/2016/08/25/SwipeToRefresh滑动冲突解决/","excerpt":"解决SwipeToRefresh嵌套ViewPager等左右滑动和下拉刷新冲突的方案","text":"解决SwipeToRefresh嵌套ViewPager等左右滑动和下拉刷新冲突的方案 自定义SwipeToRefresh12345678910111213141516171819202122232425262728293031323334353637383940import android.content.Context;import android.support.v4.widget.SwipeRefreshLayout;import android.util.AttributeSet;import android.view.MotionEvent;import android.view.ViewConfiguration;/** * 解决SwipeToRefresh嵌套ViewPager等左右滑动和下拉刷新冲突的方案 */public class HorizontalSwipeToRefresh extends SwipeRefreshLayout &#123; private int mTouchSlop; private float mPrevX; public HorizontalSwipeToRefresh(Context context, AttributeSet attrs) &#123; super(context, attrs); mTouchSlop = ViewConfiguration.get(context).getScaledTouchSlop(); &#125; @Override public boolean onInterceptTouchEvent(MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: mPrevX = MotionEvent.obtain(event).getX(); break; case MotionEvent.ACTION_MOVE: final float eventX = event.getX(); float xDiff = Math.abs(eventX - mPrevX); if (xDiff &gt; mTouchSlop) &#123; return false; &#125; &#125; return super.onInterceptTouchEvent(event); &#125;&#125;","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://itdais.com/tags/Android/"},{"name":"SwipeToRefresh","slug":"SwipeToRefresh","permalink":"http://itdais.com/tags/SwipeToRefresh/"},{"name":"滑动冲突","slug":"滑动冲突","permalink":"http://itdais.com/tags/滑动冲突/"},{"name":"自定义控件","slug":"自定义控件","permalink":"http://itdais.com/tags/自定义控件/"}]},{"title":"EditText限制输入小数点后两位","slug":"EditText限制输入小数点后两位","date":"2016-07-28T12:37:32.000Z","updated":"2016-08-02T13:21:14.544Z","comments":true,"path":"2016/07/28/EditText限制输入小数点后两位/","link":"","permalink":"http://itdais.com/2016/07/28/EditText限制输入小数点后两位/","excerpt":"实现EditText只能输入小数点后两位的控制,主要是给EditText添加输入监听事件","text":"实现EditText只能输入小数点后两位的控制,主要是给EditText添加输入监听事件 1、设置EditTextEditText设置输入类型为浮点型1android:inputType=\"numberDecimal\" 设置监听1mEditText.addTextChangedListener(new MyTextWatcher()); 2、监听器123456789101112131415161718192021222324252627282930313233343536373839class MyTextWatcher implements TextWatcher&#123; @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) &#123; &#125; @Override public void onTextChanged(CharSequence s, int start, int before, int count) &#123; if (s.toString().contains(\".\")) &#123; if (s.length() - 1 - s.toString().indexOf(\".\") &gt; 2) &#123; s = s.toString().subSequence(0, s.toString().indexOf(\".\") + 3); mEditText.setText(s); mEditText.setSelection(s.length()); &#125; &#125; if (s.toString().trim().substring(0).equals(\".\")) &#123; s = \"0\" + s; mEditText.setText(s); mEditText.setSelection(2); &#125; if (s.toString().startsWith(\"0\") &amp;&amp; s.toString().trim().length() &gt; 1) &#123; if (!s.toString().substring(1, 2).equals(\".\")) &#123; mEditText.setText(s.subSequence(0, 1)); mEditText.setSelection(1); return; &#125; &#125; &#125; @Override public void afterTextChanged(Editable s) &#123; &#125;&#125; 当前已经实现了小数点后两位的控制了 3、拓展实现当我们没有输入小数点，格式化数据为#.00的格式 12345678910111213141516171819202122232425262728//判断是不是浮点型public static boolean isFolat(String value) &#123; boolean bCheckResult = true; try &#123; Float dCheckValue = Float.parseFloat(value); if (dCheckValue instanceof Float == false) &#123; bCheckResult = false; &#125; &#125; catch (NumberFormatException e) &#123; bCheckResult = false; &#125; return bCheckResult; &#125; /** * 格式化字符串 */ public static String formatFloat(String str) &#123; if (isFolat(str)) &#123; DecimalFormat format = new DecimalFormat(\"#0.00\"); return format.format(Double.parseDouble(str)); &#125; else &#123; return str; &#125; &#125;","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://itdais.com/tags/Android/"},{"name":"Widget","slug":"Widget","permalink":"http://itdais.com/tags/Widget/"},{"name":"EditText","slug":"EditText","permalink":"http://itdais.com/tags/EditText/"}]},{"title":"加载Https的图片","slug":"加载Https的图片","date":"2016-07-20T13:25:20.000Z","updated":"2016-07-28T13:04:00.584Z","comments":true,"path":"2016/07/20/加载Https的图片/","link":"","permalink":"http://itdais.com/2016/07/20/加载Https的图片/","excerpt":"本文介绍的是如何在项目中加载已Https为开头的图片，图片加载框架是Glide和UIL,当加载图片时候禁用掉所有的 SSL 证书检查。","text":"本文介绍的是如何在项目中加载已Https为开头的图片，图片加载框架是Glide和UIL,当加载图片时候禁用掉所有的 SSL 证书检查。 UIL加载图片 ImageLoader我们需要自己写一个图片加载替换掉原有的imageDownloader,在application中配置就可以了 在Application中初始化ImageLoader 12345678910111213141516171819202122232425public class MyApplication extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); //设置OKHttp 支持https请求 OkHttpUtils.getInstance().setCertificates(); initImageLoader(); &#125; private void initImageLoader() &#123; ImageLoaderConfiguration config = new ImageLoaderConfiguration .Builder(getApplicationContext()) .threadPriority(Thread.NORM_PRIORITY - 2) .denyCacheImageMultipleSizesInMemory() .diskCacheFileNameGenerator(new Md5FileNameGenerator()) //替换允许Https的图片加载 .imageDownloader(new AuthImageDownloader(this)) .tasksProcessingOrder(QueueProcessingType.LIFO).build(); ImageLoader.getInstance().init(config); &#125; &#125; AuthImageDownloader代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101import com.nostra13.universalimageloader.core.download.BaseImageDownloader;import java.io.BufferedInputStream;import java.io.IOException;import java.io.InputStream;import java.net.HttpURLConnection;import java.net.MalformedURLException;import java.net.URL;import java.security.KeyManagementException;import java.security.NoSuchAlgorithmException;import javax.net.ssl.HostnameVerifier;import javax.net.ssl.HttpsURLConnection;import javax.net.ssl.SSLContext;import javax.net.ssl.SSLSession;import javax.net.ssl.SSLSocketFactory;/** * HTTPS的图片加载 */public class AuthImageDownloader extends BaseImageDownloader &#123; private SSLSocketFactory mSSLSocketFactory; public AuthImageDownloader(Context context) &#123; super(context); SSLContext sslContext = sslContextForTrustedCertificates(); mSSLSocketFactory = sslContext.getSocketFactory(); &#125; public AuthImageDownloader(Context context, int connectTimeout, int readTimeout) &#123; super(context, connectTimeout, readTimeout); SSLContext sslContext = sslContextForTrustedCertificates(); mSSLSocketFactory = sslContext.getSocketFactory(); &#125; @Override protected InputStream getStreamFromNetwork(String imageUri, Object extra) throws IOException &#123; URL url = null; try &#123; url = new URL(imageUri); &#125; catch (MalformedURLException e) &#123; &#125; HttpURLConnection conn = (HttpURLConnection) url.openConnection(); conn.setConnectTimeout(connectTimeout); conn.setReadTimeout(readTimeout); if (conn instanceof HttpsURLConnection) &#123; ((HttpsURLConnection)conn).setSSLSocketFactory(mSSLSocketFactory); ((HttpsURLConnection)conn).setHostnameVerifier((DO_NOT_VERIFY)); &#125; return new BufferedInputStream(conn.getInputStream(), BUFFER_SIZE); &#125; // always verify the host - dont check for certificate final HostnameVerifier DO_NOT_VERIFY = new HostnameVerifier() &#123; @Override public boolean verify(String hostname, SSLSession session) &#123; return true; &#125; &#125;; public SSLContext sslContextForTrustedCertificates() &#123; javax.net.ssl.TrustManager[] trustAllCerts = new javax.net.ssl.TrustManager[1]; javax.net.ssl.TrustManager tm = new miTM(); trustAllCerts[0] = tm; SSLContext sc = null; try &#123; sc = SSLContext.getInstance(\"SSL\"); sc.init(null, trustAllCerts, null); //javax.net.ssl.HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory()); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125;catch (KeyManagementException e) &#123; e.printStackTrace(); &#125;finally &#123; return sc; &#125; &#125; class miTM implements javax.net.ssl.TrustManager, javax.net.ssl.X509TrustManager &#123; public java.security.cert.X509Certificate[] getAcceptedIssuers() &#123; return null; &#125; public boolean isServerTrusted( java.security.cert.X509Certificate[] certs) &#123; return true; &#125; public boolean isClientTrusted( java.security.cert.X509Certificate[] certs) &#123; return true; &#125; public void checkServerTrusted( java.security.cert.X509Certificate[] certs, String authType) throws java.security.cert.CertificateException &#123; return; &#125; public void checkClientTrusted( java.security.cert.X509Certificate[] certs, String authType) throws java.security.cert.CertificateException &#123; return; &#125; &#125;&#125; Glide加载图片Glide加载Https需要自定义Module,并且要整合Okhttp,让okhttp禁用掉所有的 SSL 证书检查。 gradle引用 引用中介绍的比较麻烦,Glide已经提供了Module给我们使用。 1234compile 'com.squareup.okhttp3:okhttp:3.3.1'compile 'com.github.bumptech.glide:glide:3.7.0'/*提供的Module*/compile 'com.github.bumptech.glide:okhttp3-integration:1.4.0@aar' application中初始化 12//让Glide能用HTTPSGlide.get(this).register(GlideUrl.class, InputStream.class, new OkHttpUrlLoader.Factory(RetrofitUtils.getOkHttpClient())); 设置证书这个不是必须的,当你没有证书的时候,就不需要获取,如果有就拿到InputStream,传到下面的getOkHttpClient()的方法中 12345try &#123; InputStream input = getAssets().open(\"server.cer\");&#125; catch (IOException e) &#123; e.printStackTrace();&#125; 配置OkHttp允许Https 获取OkHttpClien 123456789101112131415161718/** * 获取OkHttpClient * 设置允许HTTPS * */public static OkHttpClient getOkHttpClient(InputStream... certificates)&#123; SSLSocketFactory sslSocketFactory = HttpsUtils.getSslSocketFactory(certificates, null, null); OkHttpClient.Builder builder = new OkHttpClient().newBuilder(); builder = builder.sslSocketFactory(sslSocketFactory); builder.hostnameVerifier(new HostnameVerifier() &#123; @Override public boolean verify(String hostname, SSLSession session) &#123; return true; &#125; &#125;); return builder.build();&#125; HttpsUtils中可以传递证书进入,如果没有证书就传null 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164import java.io.IOException;import java.io.InputStream;import java.security.KeyManagementException;import java.security.KeyStore;import java.security.KeyStoreException;import java.security.NoSuchAlgorithmException;import java.security.SecureRandom;import java.security.UnrecoverableKeyException;import java.security.cert.CertificateException;import java.security.cert.CertificateFactory;import java.security.cert.X509Certificate;import javax.net.ssl.HostnameVerifier;import javax.net.ssl.KeyManager;import javax.net.ssl.KeyManagerFactory;import javax.net.ssl.SSLContext;import javax.net.ssl.SSLSession;import javax.net.ssl.SSLSocketFactory;import javax.net.ssl.TrustManager;import javax.net.ssl.TrustManagerFactory;import javax.net.ssl.X509TrustManager;/** * 设置允许Https */public class HttpsUtils&#123; public static SSLSocketFactory getSslSocketFactory(InputStream[] certificates, InputStream bksFile, String password)&#123; try&#123; TrustManager[] trustManagers = prepareTrustManager(certificates); KeyManager[] keyManagers = prepareKeyManager(bksFile, password); SSLContext sslContext = SSLContext.getInstance(\"TLS\"); TrustManager trustManager = null; if (trustManagers != null)&#123; trustManager = new MyTrustManager(chooseTrustManager(trustManagers)); &#125; else&#123; trustManager = new UnSafeTrustManager(); &#125; sslContext.init(keyManagers, new TrustManager[]&#123;trustManager&#125;, new SecureRandom()); return sslContext.getSocketFactory(); &#125; catch (NoSuchAlgorithmException e)&#123; throw new AssertionError(e); &#125; catch (KeyManagementException e)&#123; throw new AssertionError(e); &#125; catch (KeyStoreException e)&#123; throw new AssertionError(e); &#125; &#125; private class UnSafeHostnameVerifier implements HostnameVerifier&#123; @Override public boolean verify(String hostname, SSLSession session)&#123; return true; &#125; &#125; private static class UnSafeTrustManager implements X509TrustManager&#123; @Override public void checkClientTrusted(X509Certificate[] chain, String authType)throws CertificateException&#123;&#125; @Override public void checkServerTrusted(X509Certificate[] chain, String authType)throws CertificateException&#123;&#125; @Override public X509Certificate[] getAcceptedIssuers()&#123; return new X509Certificate[]&#123;&#125;; &#125; &#125; private static TrustManager[] prepareTrustManager(InputStream... certificates)&#123; if (certificates == null || certificates.length &lt;= 0) return null; try&#123; CertificateFactory certificateFactory = CertificateFactory.getInstance(\"X.509\"); KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType()); keyStore.load(null); int index = 0; for (InputStream certificate : certificates)&#123; String certificateAlias = Integer.toString(index++); keyStore.setCertificateEntry(certificateAlias, certificateFactory.generateCertificate(certificate)); try&#123; if (certificate != null) certificate.close(); &#125; catch (IOException e)&#123; &#125; &#125; TrustManagerFactory trustManagerFactory = null; trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm()); trustManagerFactory.init(keyStore); TrustManager[] trustManagers = trustManagerFactory.getTrustManagers(); return trustManagers; &#125; catch (NoSuchAlgorithmException e)&#123; e.printStackTrace(); &#125; catch (CertificateException e)&#123; e.printStackTrace(); &#125; catch (KeyStoreException e)&#123; e.printStackTrace(); &#125; catch (Exception e)&#123; e.printStackTrace(); &#125; return null; &#125; private static KeyManager[] prepareKeyManager(InputStream bksFile, String password)&#123; try&#123; if (bksFile == null || password == null) return null; KeyStore clientKeyStore = KeyStore.getInstance(\"BKS\"); clientKeyStore.load(bksFile, password.toCharArray()); KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm()); keyManagerFactory.init(clientKeyStore, password.toCharArray()); return keyManagerFactory.getKeyManagers(); &#125; catch (KeyStoreException e)&#123; e.printStackTrace(); &#125; catch (NoSuchAlgorithmException e)&#123; e.printStackTrace(); &#125; catch (UnrecoverableKeyException e)&#123; e.printStackTrace(); &#125; catch (CertificateException e)&#123; e.printStackTrace(); &#125; catch (IOException e)&#123; e.printStackTrace(); &#125; catch (Exception e)&#123; e.printStackTrace(); &#125; return null; &#125; private static X509TrustManager chooseTrustManager(TrustManager[] trustManagers)&#123; for (TrustManager trustManager : trustManagers)&#123; if (trustManager instanceof X509TrustManager)&#123; return (X509TrustManager) trustManager; &#125; &#125; return null; &#125; private static class MyTrustManager implements X509TrustManager&#123; private X509TrustManager defaultTrustManager; private X509TrustManager localTrustManager; public MyTrustManager(X509TrustManager localTrustManager) throws NoSuchAlgorithmException, KeyStoreException&#123; TrustManagerFactory var4 = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm()); var4.init((KeyStore) null); defaultTrustManager = chooseTrustManager(var4.getTrustManagers()); this.localTrustManager = localTrustManager; &#125; @Override public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException&#123;&#125; @Override public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException&#123; try&#123; defaultTrustManager.checkServerTrusted(chain, authType); &#125; catch (CertificateException ce)&#123; localTrustManager.checkServerTrusted(chain, authType); &#125; &#125; @Override public X509Certificate[] getAcceptedIssuers()&#123; return new X509Certificate[0]; &#125; &#125;&#125; 所有代码引入后就可以,Glide就可以加载Https开头的图片了。 引用 完美解决imageloader加载https图片Glide加载HttpsGlide加载Https中文翻译","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://itdais.com/tags/Android/"},{"name":"图片加载","slug":"图片加载","permalink":"http://itdais.com/tags/图片加载/"},{"name":"HTTPS","slug":"HTTPS","permalink":"http://itdais.com/tags/HTTPS/"}]},{"title":"Android ADB端口被占用","slug":"Android ADB端口被占用","date":"2016-07-18T13:45:18.000Z","updated":"2016-07-28T13:04:03.531Z","comments":true,"path":"2016/07/18/Android ADB端口被占用/","link":"","permalink":"http://itdais.com/2016/07/18/Android ADB端口被占用/","excerpt":"最近几天使用android studio1.5.1的时候一直提示错误,一开始没在意,重启就好了.但是总不能一直报错就重启吧，查看下问题原因吧,发现是android adb的端口被占用了。当使用到音乐播放器如酷狗酷我或者使用了豌豆荚、360手机助手等软件时候，是会抢占掉adb的端口的。","text":"最近几天使用android studio1.5.1的时候一直提示错误,一开始没在意,重启就好了.但是总不能一直报错就重启吧，查看下问题原因吧,发现是android adb的端口被占用了。当使用到音乐播放器如酷狗酷我或者使用了豌豆荚、360手机助手等软件时候，是会抢占掉adb的端口的。 解决方法一:杀死占用进程解决方法二:重设adb的端口","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://itdais.com/tags/Android/"},{"name":"BUG","slug":"BUG","permalink":"http://itdais.com/tags/BUG/"}]},{"title":"屏幕管理工具类","slug":"屏幕管理工具类","date":"2016-07-18T13:15:20.000Z","updated":"2016-08-02T13:21:37.458Z","comments":true,"path":"2016/07/18/屏幕管理工具类/","link":"","permalink":"http://itdais.com/2016/07/18/屏幕管理工具类/","excerpt":"提供了dp互转px,sp互转px,获取屏幕宽高,获取状态栏高度、toolbar高度、底部虚拟菜单高度等等。 dp(dip): device independent pixels(设备独立像素).不同设备有不同的显示效果,这个和设备硬件有关，一般我们为了支持WVGA、HVGA和QVGA 推荐使用这个，不依赖像素。 使用dp和sp，系统会根据屏幕密度的变化自动进行转换。如果设置表示长度、高度等属性时可以使用dp。但如果设置字体，需要使用sp。dp是与密度无关，sp除了与密度无关外，还与scale无关。 px: pixels(像素). 不同设备显示效果相同，一般我们HVGA代表320x480像素，这个用的比较多。 sp: scaled pixels(放大像素). 主要用于字体显示best for textsize。","text":"提供了dp互转px,sp互转px,获取屏幕宽高,获取状态栏高度、toolbar高度、底部虚拟菜单高度等等。 dp(dip): device independent pixels(设备独立像素).不同设备有不同的显示效果,这个和设备硬件有关，一般我们为了支持WVGA、HVGA和QVGA 推荐使用这个，不依赖像素。 使用dp和sp，系统会根据屏幕密度的变化自动进行转换。如果设置表示长度、高度等属性时可以使用dp。但如果设置字体，需要使用sp。dp是与密度无关，sp除了与密度无关外，还与scale无关。 px: pixels(像素). 不同设备显示效果相同，一般我们HVGA代表320x480像素，这个用的比较多。 sp: scaled pixels(放大像素). 主要用于字体显示best for textsize。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277import android.app.Activity;import android.content.Context;import android.content.res.Configuration;import android.content.res.Resources;import android.content.res.TypedArray;import android.graphics.Bitmap;import android.graphics.Rect;import android.util.DisplayMetrics;import android.util.Log;import android.util.TypedValue;import android.view.View;import android.view.Window;public class DensityUtils &#123; private static final float DOT_FIVE = 0.5f; /** * dip to px * * @param context * @param dip * @return */ public static int dip2px(Context context, float dip) &#123; float density = getDensity(context); return (int) (dip * density + DensityUtils.DOT_FIVE); &#125; /** * px to dip * * @param context * @param px * @return */ public static int px2dip(Context context, float px) &#123; float density = getDensity(context); return (int) (px / density + DOT_FIVE); &#125; /** * 将px值转换为sp值，保证文字大小不变 * * @param pxValue * @param pxValue * （DisplayMetrics类中属性scaledDensity） * @return */ public static int px2sp(Context context, float pxValue) &#123; final float fontScale = context.getResources().getDisplayMetrics().scaledDensity; return (int) (pxValue / fontScale + 0.5f); &#125; /** * 将sp值转换为px值，保证文字大小不变 * * @param spValue * @param spValue * （DisplayMetrics类中属性scaledDensity） * @return */ public static int sp2px(Context context, float spValue) &#123; final float fontScale = context.getResources().getDisplayMetrics().scaledDensity; return (int) (spValue * fontScale + 0.5f); &#125; private static DisplayMetrics sDisplayMetrics; /** * get screen width * * @param context * @return */ public static int getDisplayWidth(Context context) &#123; initDisplayMetrics(context); return sDisplayMetrics.widthPixels; &#125; /** * get screen height * * @param context * @return */ public static int getDisplayHeight(Context context) &#123; initDisplayMetrics(context); return sDisplayMetrics.heightPixels; &#125; /** * get screen density * * @param context * @return */ public static float getDensity(Context context) &#123; initDisplayMetrics(context); return sDisplayMetrics.density; &#125; /** * get screen density dpi * * @param context * @return */ public static int getDensityDpi(Context context) &#123; initDisplayMetrics(context); return sDisplayMetrics.densityDpi; &#125; /** * init display metrics * * @param context */ private static synchronized void initDisplayMetrics(Context context) &#123; sDisplayMetrics = context.getResources().getDisplayMetrics(); &#125; /** * is landscape * * @param context * @return */ public static boolean isLandscape(Context context) &#123; return context.getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE; &#125; /** * is portrait * * @param context * @return */ public static boolean isPortrait(Context context) &#123; return context.getResources().getConfiguration().orientation == Configuration.ORIENTATION_PORTRAIT; &#125; public static int getActvieHeight(Activity activity)&#123; Dimension dimen = new Dimension(); // 用户绘制区域 Rect outRect = new Rect(); activity.getWindow().findViewById(Window.ID_ANDROID_CONTENT).getDrawingRect(outRect); dimen.mWidth = outRect.width() ; dimen.mHeight = outRect.height(); // end return dimen.mHeight; &#125; /** * 获得状态栏的高度 * * @param activity * @return */ public static int getStatusHeight(Activity activity) &#123;// Rect frame = new Rect();// activity.getWindow().getDecorView().getWindowVisibleDisplayFrame(frame);// int statusBarHeight = frame.top;// Log.d(&quot;111&quot;,&quot;statusBarHeight&quot;+statusBarHeight); int statusHeight = -1; try &#123; Class&lt;?&gt; clazz = Class.forName(&quot;com.android.internal.R$dimen&quot;); Object object = clazz.newInstance(); int height = Integer.parseInt(clazz.getField(&quot;status_bar_height&quot;) .get(object).toString()); statusHeight = activity.getResources().getDimensionPixelSize(height); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return statusHeight; &#125; public int getNavigationBarHeight(Activity activity) &#123; Resources resources = activity.getResources(); int resourceId = resources.getIdentifier(&quot;navigation_bar_height&quot;,&quot;dimen&quot;, &quot;android&quot;); int height = resources.getDimensionPixelSize(resourceId); Log.v(&quot;dbw&quot;, &quot;Navi height:&quot; + height); return height; &#125; public static int getActionBarHeight(Context context) &#123; TypedValue tv = new TypedValue(); if (context.getTheme().resolveAttribute(android.R.attr.actionBarSize, tv, true)) &#123; int actionBarHeight = TypedValue.complexToDimensionPixelSize(tv.data, context.getResources().getDisplayMetrics()); return actionBarHeight; &#125;else&#123; return 0; &#125; &#125; /** * get toolbar height * @param context * @return */ public static int getToolbarHeight(Context context) &#123; final TypedArray styledAttributes = context.getTheme().obtainStyledAttributes( new int[]&#123;android.R.attr.actionBarSize&#125;); int toolbarHeight = (int) styledAttributes.getDimension(0, 0); styledAttributes.recycle(); return toolbarHeight; &#125; private int getTitleHeight(Activity activity) &#123; int contentTop = activity.getWindow().findViewById(Window.ID_ANDROID_CONTENT).getTop(); //statusBarHeight是上面状态栏的高度 int titleBarHeight = contentTop - getStatusHeight(activity); return titleBarHeight; &#125; private int getActionBarSizeHeight(Activity activity) &#123; return activity.getActionBar().getHeight(); &#125; public static class Dimension &#123; public int mWidth ; public int mHeight ; public Dimension()&#123;&#125; &#125; /** * 获取当前屏幕截图，包含状态栏 * * @param activity * @return */ public static Bitmap snapShotWithStatusBar(Activity activity) &#123; View view = activity.getWindow().getDecorView(); view.setDrawingCacheEnabled(true); view.buildDrawingCache(); Bitmap bmp = view.getDrawingCache(); int width = getDisplayWidth(activity); int height = getDisplayHeight(activity); Bitmap bp = null; bp = Bitmap.createBitmap(bmp, 0, 0, width, height); view.destroyDrawingCache(); return bp; &#125; /** * 获取当前屏幕截图，不包含状态栏 * * @param activity * @return */ public static Bitmap snapShotWithoutStatusBar(Activity activity) &#123; View view = activity.getWindow().getDecorView(); view.setDrawingCacheEnabled(true); view.buildDrawingCache(); Bitmap bmp = view.getDrawingCache(); Rect frame = new Rect(); activity.getWindow().getDecorView().getWindowVisibleDisplayFrame(frame); int statusBarHeight = frame.top; int width = getDisplayWidth(activity); int height = getDisplayHeight(activity); Bitmap bp = null; bp = Bitmap.createBitmap(bmp, 0, statusBarHeight, width, height - statusBarHeight); view.destroyDrawingCache(); return bp; &#125;&#125;","categories":[{"name":"archives","slug":"archives","permalink":"http://itdais.com/categories/archives/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://itdais.com/tags/Android/"},{"name":"屏幕","slug":"屏幕","permalink":"http://itdais.com/tags/屏幕/"},{"name":"工具类","slug":"工具类","permalink":"http://itdais.com/tags/工具类/"}]},{"title":"通用验证工具类","slug":"通用验证工具类","date":"2016-07-06T15:02:10.000Z","updated":"2016-07-28T13:04:02.041Z","comments":true,"path":"2016/07/06/通用验证工具类/","link":"","permalink":"http://itdais.com/2016/07/06/通用验证工具类/","excerpt":"本文收集了一些常用的验证方法,如手机号码验证、银行卡验证等，以后会不定期的更新","text":"本文收集了一些常用的验证方法,如手机号码验证、银行卡验证等，以后会不定期的更新 1、手机号码验证123456789101112/** * 判断手机格式是否正确 * 表示以1开头，第二位可能是3/4/5/7/8等的任意一个，在加上后面的\\d表示数字[0-9]的9位，总共加起来11位结束 * * @return true 是手机号码 */public static boolean isMobile(String mobiles)&#123; Pattern p = Pattern.compile(\"^1[3|4|5|7|8]\\\\d&#123;9&#125;$\"); Matcher m = p.matcher(mobiles); return m.matches();&#125; 2、中文验证12345678910/** * 检查是否全部是中文 * @return true 全是中文 */public static boolean isChinaise(String body)&#123; Pattern p = Pattern.compile(\"^[\\\\u4e00-\\\\u9fa5]+\"); Matcher m = p.matcher(body); return m.matches();&#125; 3、银行卡校验Luhn检验数字算法（Luhn Check Digit Algorithm），也叫做模数10公式，是一种简单的算法，用于验证银行卡、信用卡号码的有效性的算法。对所有大型信用卡公司发行的信用卡都起作用，这些公司包括美国Express、护照、万事达卡、Discover和用餐者俱乐部等。这种算法最初是在20世纪60年代由一组数学家制定，现在Luhn检验数字算法属于大众，任何人都可以使用它。 算法：将每个奇数加倍和使它变为单个的数字，如果必要的话通过减去9和在每个偶数上加上这些值。如果此卡要有效，那么，结果必须是10的倍数。 该校验的过程：1、从卡号最后一位数字开始，逆向将奇数位(1、3、5等等)相加。2、从卡号最后一位数字开始，逆向将偶数位数字，先乘以2（如果乘积为两位数，则将其减去9），再求和。3、将奇数位总和加上偶数位总和，结果应该可以被10整除。12345678910111213141516171819202122232425262728293031323334353637383940/** * 校验银行卡卡号 * * @param cardId * @return */ public static boolean isBankCard(String cardId) &#123; char bit = getBankCardCheckCode(cardId.substring(0, cardId.length() - 1)); if (bit == 'N') &#123; return false; &#125; return cardId.charAt(cardId.length() - 1) == bit; &#125; /** * 从不含校验位的银行卡卡号采用 Luhn 校验算法获得校验位 * * @param nonCheckCodeCardId * @return */ public static char getBankCardCheckCode(String nonCheckCodeCardId) &#123; if (nonCheckCodeCardId == null || nonCheckCodeCardId.trim().length() == 0 || !nonCheckCodeCardId.matches(\"\\\\d+\")) &#123; //如果传的不是数据返回N return 'N'; &#125; char[] chs = nonCheckCodeCardId.trim().toCharArray(); int luhmSum = 0; for (int i = chs.length - 1, j = 0; i &gt;= 0; i--, j++) &#123; int k = chs[i] - '0'; if (j % 2 == 0) &#123; k *= 2; k = k / 10 + k % 10; &#125; luhmSum += k; &#125; return (luhmSum % 10 == 0) ? '0' : (char) ((10 - luhmSum % 10) + '0'); &#125;","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://itdais.com/tags/Android/"},{"name":"工具类","slug":"工具类","permalink":"http://itdais.com/tags/工具类/"}]},{"title":"Hello World","slug":"hello-world","date":"2016-07-04T15:05:44.269Z","updated":"2016-07-04T15:05:44.270Z","comments":true,"path":"2016/07/04/hello-world/","link":"","permalink":"http://itdais.com/2016/07/04/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}